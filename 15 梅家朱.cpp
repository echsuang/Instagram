#include <opencv2/opencv.hpp>
#include <iostream>
#include <string>
#include <sstream>

using namespace cv;
using namespace std;

// 全局變數
bool freeze = false;        // 是否停止畫面
Rect buttonRect;            // 圓形按鈕區域 (停止/恢復)
Rect importButtonRect;      // 匯入圖片按鈕區域
Mat importedImage;          // 匯入的圖片
Mat capturedFrame;          // 儲存拍照的畫面
bool showButtons = true;    // 是否顯示按鈕
VideoCapture cap(0);        // 將 VideoCapture 設為全局變數
int saveCounter = 1;        // 儲存計數器
Mat baseFrame;
int brightness = 50;
int contrast = 50;
int thresh = 127;
int mode = 0;
int prev_mode = -1;

bool initialized = false;
int setColorTarget = 0;

Vec3b blackColor1(0, 0, 0), blackColor2(0, 0, 0);
Vec3b whiteColor1(255, 255, 255), whiteColor2(255, 255, 255);
bool blackColor1Set = false, blackColor2Set = false;
bool whiteColor1Set = false, whiteColor2Set = false;

int r = 0, g = 0, b = 0;

// 滑鼠回呼函數
void mouseCallback(int event, int x, int y, int flags, void* userdata) {
    if (event == EVENT_LBUTTONDOWN) {
        Point clickPoint(x, y);

        // 停止/恢復按鈕
        if (showButtons && buttonRect.contains(clickPoint) && importedImage.empty()) {
            freeze = !freeze; // 切換凍結狀態
            cout << (freeze ? "畫面已凍結。" : "畫面已恢復。") << endl;
            showButtons = !freeze; // 同步更新 showButtons 的狀態
            if (freeze && capturedFrame.empty()) {
                // 在凍結時保存當前畫面
                Mat tempFrame;
                cap >> tempFrame;
                if (!tempFrame.empty()) {
                    int frame_width = tempFrame.cols;
                    int frame_height = tempFrame.rows;
                    int crop_height = frame_height;
                    int crop_width = crop_height * 9 / 16;
                    if (crop_width > frame_width) {
                        crop_width = frame_width;
                        crop_height = crop_width * 16 / 9;
                    }
                    int x_offset = (frame_width - crop_width) / 2;
                    int y_offset = (frame_height - crop_height) / 2;
                    Rect roi(x_offset, y_offset, crop_width, crop_height);
                    capturedFrame = tempFrame(roi).clone();
                }
                else {
                    cout << "警告：凍結時無法讀取畫面。" << endl;
                    freeze = false; // 如果無法讀取，則取消凍結
                    showButtons = true; // 取消凍結時重新顯示按鈕
                }
            }
        }

        // 匯入圖片按鈕
        if (showButtons && importButtonRect.contains(clickPoint) && importedImage.empty()) {
            string path;
            cout << "請輸入圖片路徑：";
            cin >> path;
            Mat img = imread(path);
            if (!img.empty()) {
                cout << "讀取圖片成功，尺寸為：" << img.cols << "x" << img.rows << endl;

                Size targetSize(360, 640); // 預設畫面大小
                Mat processed;

                if (img.cols > img.rows) {
                    // 橫式照片：等比例縮放寬度為 360，高度自動調整
                    float scale = (float)targetSize.width / img.cols;
                    int newHeight = img.rows * scale;
                    resize(img, processed, Size(targetSize.width, newHeight));
                    Mat background = Mat::zeros(targetSize, img.type());
                    int y_offset = (targetSize.height - newHeight) / 2;
                    processed.copyTo(background(Rect(0, y_offset, targetSize.width, newHeight)));
                    importedImage = background;
                    cout << "這是橫式照片，已置中顯示。" << endl;
                }
                else {
                    // 直式或正方形照片：等比例縮放高度為 640，寬度可能超過
                    float scale = (float)targetSize.height / img.rows;
                    int newWidth = img.cols * scale;
                    resize(img, processed, Size(newWidth, targetSize.height));
                    int x_offset = (newWidth - targetSize.width) / 2;
                    Rect cropRegion(x_offset, 0, targetSize.width, targetSize.height);
                    importedImage = processed(cropRegion).clone();
                    cout << "這是直式或正方形照片，已裁切置中顯示。" << endl;
                }
                freeze = true;
                showButtons = false; // 匯入圖片後也隱藏按鈕
                cout << "圖片匯入成功！" << endl;
            }
            else {
                cout << "無法讀取圖片，請確認路徑是否正確。" << endl;
            }
        }
    }
}

void on_trackbar(int, void*) {
    Mat color(300, 300, CV_8UC3, Scalar(b, g, r));
    imshow("Color Mixer", color);
}

Vec3b getCurrentColor() {
    return Vec3b(b, g, r);
}

Mat adjustBrightness(const Mat& src, int brightness) {
    int bright = brightness - 50;
    Mat result;
    src.convertTo(result, -1, 1.0, bright);
    return result;
}

Mat adjustContrast(const Mat& src, int contrast) {
    double con = contrast / 50.0;
    Mat result;
    src.convertTo(result, -1, con, 0);
    return result;
}

Mat NOT(const Mat& src) {
    Mat result;
    bitwise_not(src, result);
    return result;
}

Mat THRESH(const Mat& src, int thresh) {
    Mat result, gray;
    cvtColor(src, gray, COLOR_BGR2GRAY);
    threshold(gray, result, thresh, 255, 0);
    return result;
}

Mat GRAD(const Mat& src, int thresh) {
    Mat gray, dst;
    cvtColor(src, gray, COLOR_BGR2GRAY);
    threshold(gray, dst, thresh, 255, 0);

    if (!(blackColor1Set && blackColor2Set) && !(whiteColor1Set && whiteColor2Set)) {
        Mat binBGR;
        cvtColor(dst, binBGR, COLOR_GRAY2BGR);
        return binBGR;
    }

    Mat result = src.clone();
    int height = dst.rows;

    for (int row = 0; row < height; row++) {
        float alpha = static_cast<float>(row) / (height - 1);
        Vec3b gradBlack, gradWhite;

        for (int ch = 0; ch < 3; ch++) {
            gradBlack[ch] = static_cast<uchar>((1 - alpha) * blackColor1[ch] + alpha * blackColor2[ch]);
            gradWhite[ch] = static_cast<uchar>((1 - alpha) * whiteColor1[ch] + alpha * whiteColor2[ch]);
        }

        for (int col = 0; col < dst.cols; col++) {
            if (dst.at<uchar>(row, col) == 0 && blackColor1Set && blackColor2Set) {
                result.at<Vec3b>(row, col) = gradBlack;
            }
            else if (dst.at<uchar>(row, col) != 0 && whiteColor1Set && whiteColor2Set) {
                result.at<Vec3b>(row, col) = gradWhite;
            }
            else {
                result.at<Vec3b>(row, col) = Vec3b(dst.at<uchar>(row, col)); // fallback to gray
            }
        }
    }

    return result;
}

int main() {
    if (!cap.isOpened()) return -1;

    cap.set(CAP_PROP_FRAME_WIDTH, 640);
    cap.set(CAP_PROP_FRAME_HEIGHT, 480);

    namedWindow("Portrait 9:16 Crop", WINDOW_AUTOSIZE);
    resizeWindow("Portrait 9:16 Crop", 360, 640);        // 設定視窗尺寸
    moveWindow("Portrait 9:16 Crop", 100, 100);         // 將視窗移動到畫面位置，避免被遮住
    setMouseCallback("Portrait 9:16 Crop", mouseCallback); // 設定滑鼠回呼

    createTrackbar("Brightness", "Portrait 9:16 Crop", &brightness, 100, nullptr);
    createTrackbar("Contrast", "Portrait 9:16 Crop", &contrast, 100, nullptr);
    createTrackbar("Thresh", "Portrait 9:16 Crop", &thresh, 255, nullptr);

    Mat frame;
    Mat lastFrame;

    while (true) {
        if (!freeze && importedImage.empty()) { // 只有在未凍結且沒有匯入圖片時才讀取攝影機
            cap >> frame;
            if (frame.empty()) break;

            // --- 9:16 裁切 ---
            /*原攝影機的長寬*/
            int frame_width = frame.cols;
            int frame_height = frame.rows;

            /*顯示的長寬*/
            int crop_height = frame_height;
            int crop_width = crop_height * 9 / 16;
            /*檢查新的寬度是否超過原攝影機的長寬，如果超過就把寬當高，再重新計算*/
            if (crop_width > frame_width) {
                crop_width = frame_width;
                crop_height = crop_width * 16 / 9;
            }
            /*計算出原攝影機顯示畫面左上角的座標*/
            int x = (frame_width - crop_width) / 2;
            int y = (frame_height - crop_height) / 2;

            /*定義出要裁切的範圍*/
            Rect roi(x, y, crop_width, crop_height);
            frame = frame(roi).clone();

            lastFrame = frame.clone(); // 保存當前畫面
        }

        Mat display;
        if (!importedImage.empty()) {
            display = importedImage.clone(); // 顯示匯入的圖片
        }
        else {
            display = lastFrame.clone();        // 顯示攝影機畫面或凍結的畫面
        }
        if (mode == 1) {
            display = adjustBrightness(display, brightness);
        }
        else if (mode == 2) {
            display = adjustContrast(display, contrast);
        }
        else if (mode == 3) {
            display = NOT(display);
        }
        else if (mode == 4) {
            display = THRESH(display, thresh);
        }
        else if (mode == 5) {
            if (!initialized) {
                namedWindow("Color Mixer", WINDOW_AUTOSIZE);
                createTrackbar("Red", "Color Mixer", &r, 255, on_trackbar);
                createTrackbar("Green", "Color Mixer", &g, 255, on_trackbar);
                createTrackbar("Blue", "Color Mixer", &b, 255, on_trackbar);
                on_trackbar(0, 0);
                initialized = true;
                setColorTarget = 0;
                std::cout << "按b填入黑色區塊的第一種顏色\n";
                std::cout << "按n填入黑色區塊的第二種顏色\n";
                std::cout << "按w填入白色區塊的第一種顏色\n";
                std::cout << "按m填入白色區塊的第二種顏色\n";
            }

            if (setColorTarget == 1) {
                blackColor1 = getCurrentColor();
                blackColor1Set = true;
                std::cout << "黑色漸層起始色已設定\n";
            }
            else if (setColorTarget == 2) {
                blackColor2 = getCurrentColor();
                blackColor2Set = true;
                std::cout << "黑色漸層結束色已設定\n";
            }
            else if (setColorTarget == 3) {
                whiteColor1 = getCurrentColor();
                whiteColor1Set = true;
                std::cout << "白色漸層起始色已設定\n";
            }
            else if (setColorTarget == 4) {
                whiteColor2 = getCurrentColor();
                whiteColor2Set = true;
                std::cout << "白色漸層結束色已設定\n";
            }

            setColorTarget = 0;
            display = GRAD(display, thresh);
        }

        if (prev_mode == 5 && mode != 5) {
            destroyWindow("Color Mixer");
            initialized = false;
        }
        prev_mode = mode;

        if (!freeze) {
            int r = 30;
            Point center(display.cols / 2, display.rows - r - 10);
            circle(display, center, r, Scalar(255, 255, 255), FILLED);
            buttonRect = Rect(center.x - r, center.y - r, r * 2, r * 2);
        }
        imshow("Portrait 9:16 Crop", display);
    

        // 只有在 showButtons 為 true 且沒有匯入圖片時才繪製按鈕
        if (showButtons && importedImage.empty()) {
            int button_radius = 30;
            Point button_center(display.cols / 2, display.rows - button_radius - 10);
            circle(display, button_center, button_radius, Scalar(255, 255, 255), FILLED);
            //偵測滑鼠點擊範圍(但偵測範圍是能夠包含此圓形的最小方形，所以點擊到附近的空白處還是會凍結畫面)
            //rect(最左上角的x座標,最左上角的y座標,矩形寬度,矩形高度)
            buttonRect = Rect(button_center.x - button_radius, button_center.y - button_radius, button_radius * 2, button_radius * 2);

            int square_size = 25;
            //最左上角距離左邊界10，底部往上邊長+10
            Point import_top_left(10, display.rows - square_size - 10);
            rectangle(display, Rect(import_top_left.x, import_top_left.y, square_size, square_size), Scalar(255, 255, 255), 2);
            importButtonRect = Rect(import_top_left.x, import_top_left.y, square_size, square_size);
        }
        else {
            // 如果有匯入圖片，則不繪製按鈕，並將按鈕區域設定為無效
            buttonRect = Rect();
            importButtonRect = Rect();
        }

        imshow("Portrait 9:16 Crop", display);

        char key = waitKey(30);
        if (key == 27) { // ESC
            cout << "退出程式" << endl;
            break;
        }
        else if (key >= '0' && key <= '5') {
            mode = key - '0';
        }
        else if (mode == 5 && key == 'b') {
            setColorTarget = 1; // 黑起始
        }
        else if (mode == 5 && key == 'n') {
            setColorTarget = 2; // 黑結束
        }
        else if (mode == 5 && key == 'w') {
            setColorTarget = 3; // 白起始
        }
        else if (mode == 5 && key == 'm') {
            setColorTarget = 4; // 白結束
        }
        else if (key == 82 || key == 114) { // R or r
            importedImage.release();
            capturedFrame.release();
            freeze = false;
            showButtons = true; // 重設後顯示按鈕
            cout << "已重設所有圖片，恢復即時攝影機畫面。" << endl;
        }
        else if (key == 83 || key == 115) { // S or s
            Mat imageToSave;
            string filename;
            if (!importedImage.empty()) {
                imageToSave = importedImage;
                stringstream filenameSS;
                filenameSS << "image_" << saveCounter << ".jpg"; // 使用相同的檔名格式和計數器
                filename = filenameSS.str();
                cout << "將匯入的圖片儲存為：" << filename << endl;
                saveCounter++; // 遞增計數器
            }
            else if (freeze && !capturedFrame.empty()) {
                imageToSave = capturedFrame;
                stringstream filenameSS;
                filenameSS << "image_" << saveCounter << ".jpg"; // 使用相同的檔名格式和計數器
                filename = filenameSS.str();
                cout << "已儲存凍結的畫面為：" << filename << endl;
                saveCounter++; // 遞增計數器
            }
            else {
                cout << "目前沒有可儲存的圖片 (沒有匯入圖片且畫面未凍結)。" << endl;
                continue;
            }
            if (!imageToSave.empty()) {
                if (imwrite(filename, imageToSave)) {
                    cout << "圖片已儲存為：" << filename << endl;
                }
                else {
                    cout << "儲存圖片失敗。" << endl;
                }
            }
        }
    }
    return 0;
}